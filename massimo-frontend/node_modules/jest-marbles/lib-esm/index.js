import { ColdObservable } from './src/rxjs/cold-observable';
import { HotObservable } from './src/rxjs/hot-observable';
import { Scheduler } from './src/rxjs/scheduler';
import { stripAlignmentChars } from './src/rxjs/strip-alignment-chars';
export { Scheduler } from './src/rxjs/scheduler';
export function hot(marbles, values, error) {
    return new HotObservable(stripAlignmentChars(marbles), values, error);
}
export function cold(marbles, values, error) {
    return new ColdObservable(stripAlignmentChars(marbles), values, error);
}
export function time(marbles) {
    return Scheduler.get().createTime(stripAlignmentChars(marbles));
}
const dummyResult = {
    message: () => '',
    pass: true
};
expect.extend({
    toHaveSubscriptions(actual, marbles) {
        const sanitizedMarbles = Array.isArray(marbles) ? marbles.map(stripAlignmentChars) : stripAlignmentChars(marbles);
        Scheduler.get().expectSubscriptions(actual.getSubscriptions()).toBe(sanitizedMarbles);
        return dummyResult;
    },
    toHaveNoSubscriptions(actual) {
        Scheduler.get().expectSubscriptions(actual.getSubscriptions()).toBe([]);
        return dummyResult;
    },
    toBeObservable(actual, expected) {
        Scheduler.get().expectObservable(actual).toBe(expected.marbles, expected.values, expected.error);
        return dummyResult;
    },
    toBeMarble(actual, marbles) {
        Scheduler.get().expectObservable(actual).toBe(stripAlignmentChars(marbles));
        return dummyResult;
    },
    toSatisfyOnFlush(actual, func) {
        Scheduler.get().expectObservable(actual);
        // tslint:disable:no-string-literal
        const flushTests = Scheduler.get()['flushTests'];
        flushTests[flushTests.length - 1].ready = true;
        onFlush.push(func);
        return dummyResult;
    }
});
let onFlush = [];
beforeEach(() => { Scheduler.init(); onFlush = []; });
afterEach(() => {
    Scheduler.get().flush();
    while (onFlush.length > 0) {
        // @ts-ignore
        onFlush.shift()();
    }
    Scheduler.reset();
});
//# sourceMappingURL=index.js.map