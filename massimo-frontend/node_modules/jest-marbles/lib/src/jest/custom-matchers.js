import { equals } from 'expect/build/jasmineUtils';
import * as diff from 'jest-diff';
import { matcherHint, printExpected, printReceived } from 'jest-matcher-utils';
import { Marblizer } from '../marblizer';
function canMarblize() {
    var messages = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        messages[_i] = arguments[_i];
    }
    return messages.every(function (message) { return message.filter(function (_a) {
        var kind = _a.notification.kind;
        return kind === 'N';
    }).every(isCharacter); });
}
function isCharacter(_a) {
    var value = _a.notification.value;
    return ((typeof value === 'string' && value.length === 1) || (value !== undefined && JSON.stringify(value).length === 1));
}
export var customTestMatchers = {
    toBeNotifications: function (actual, expected) {
        var actualMarble = actual;
        var expectedMarble = expected;
        if (canMarblize(actual, expected)) {
            actualMarble = Marblizer.marblize(actual);
            expectedMarble = Marblizer.marblize(expected);
        }
        var pass = equals(actualMarble, expectedMarble);
        var message = pass
            ? function () {
                return matcherHint('.not.toBeNotifications') +
                    '\n\n' +
                    "Expected notifications to not be:\n" +
                    ("  " + printExpected(expectedMarble) + "\n") +
                    "But got:\n" +
                    ("  " + printReceived(actualMarble));
            }
            : function () {
                var diffString = diff(expectedMarble, actualMarble, {
                    expand: true,
                });
                return (matcherHint('.toBeNotifications') +
                    '\n\n' +
                    "Expected notifications to be:\n" +
                    ("  " + printExpected(expectedMarble) + "\n") +
                    "But got:\n" +
                    ("  " + printReceived(actualMarble)) +
                    (diffString ? "\n\nDifference:\n\n" + diffString : ''));
            };
        return { actual: actual, message: message, pass: pass };
    },
    toBeSubscriptions: function (actual, expected) {
        var actualMarbleArray = Marblizer.marblizeSubscriptions(actual);
        var expectedMarbleArray = Marblizer.marblizeSubscriptions(expected);
        var pass = subscriptionsPass(actualMarbleArray, expectedMarbleArray);
        var message = pass
            ? function () {
                return matcherHint('.not.toHaveSubscriptions') +
                    '\n\n' +
                    "Expected observable to not have the following subscription points:\n" +
                    ("  " + printExpected(expectedMarbleArray) + "\n") +
                    "But got:\n" +
                    ("  " + printReceived(actualMarbleArray));
            }
            : function () {
                var diffString = diff(expectedMarbleArray, actualMarbleArray, {
                    expand: true,
                });
                return (matcherHint('.toHaveSubscriptions') +
                    '\n\n' +
                    "Expected observable to have the following subscription points:\n" +
                    ("  " + printExpected(expectedMarbleArray) + "\n") +
                    "But got:\n" +
                    ("  " + printReceived(actualMarbleArray)) +
                    (diffString ? "\n\nDifference:\n\n" + diffString : ''));
            };
        return { actual: actual, message: message, pass: pass };
    },
    toHaveEmptySubscriptions: function (actual) {
        var pass = !(actual && actual.length > 0);
        var marbles;
        if (actual && actual.length > 0) {
            marbles = Marblizer.marblizeSubscriptions(actual);
        }
        var message = pass
            ? function () {
                return matcherHint('.not.toHaveNoSubscriptions') +
                    '\n\n' +
                    "Expected observable to have at least one subscription point, but got nothing" +
                    printReceived('');
            }
            : function () {
                return matcherHint('.toHaveNoSubscriptions') +
                    '\n\n' +
                    "Expected observable to have no subscription points\n" +
                    "But got:\n" +
                    ("  " + printReceived(marbles) + "\n\n");
            };
        return { actual: actual, message: message, pass: pass };
    },
};
function subscriptionsPass(actualMarbleArray, expectedMarbleArray) {
    if (actualMarbleArray.length !== expectedMarbleArray.length) {
        return false;
    }
    var pass = true;
    for (var _i = 0, actualMarbleArray_1 = actualMarbleArray; _i < actualMarbleArray_1.length; _i++) {
        var actualMarble = actualMarbleArray_1[_i];
        if (!expectedMarbleArray.includes(actualMarble)) {
            pass = false;
            break;
        }
    }
    return pass;
}
expect.extend(customTestMatchers);
//# sourceMappingURL=custom-matchers.js.map