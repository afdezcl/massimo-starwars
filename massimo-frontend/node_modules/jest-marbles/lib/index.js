import { ColdObservable } from './src/rxjs/cold-observable';
import { HotObservable } from './src/rxjs/hot-observable';
import { Scheduler } from './src/rxjs/scheduler';
import { stripAlignmentChars } from './src/rxjs/strip-alignment-chars';
export { Scheduler } from './src/rxjs/scheduler';
export function hot(marbles, values, error) {
    return new HotObservable(stripAlignmentChars(marbles), values, error);
}
export function cold(marbles, values, error) {
    return new ColdObservable(stripAlignmentChars(marbles), values, error);
}
export function time(marbles) {
    return Scheduler.get().createTime(stripAlignmentChars(marbles));
}
var dummyResult = {
    message: function () { return ''; },
    pass: true
};
expect.extend({
    toHaveSubscriptions: function (actual, marbles) {
        var sanitizedMarbles = Array.isArray(marbles) ? marbles.map(stripAlignmentChars) : stripAlignmentChars(marbles);
        Scheduler.get().expectSubscriptions(actual.getSubscriptions()).toBe(sanitizedMarbles);
        return dummyResult;
    },
    toHaveNoSubscriptions: function (actual) {
        Scheduler.get().expectSubscriptions(actual.getSubscriptions()).toBe([]);
        return dummyResult;
    },
    toBeObservable: function (actual, expected) {
        Scheduler.get().expectObservable(actual).toBe(expected.marbles, expected.values, expected.error);
        return dummyResult;
    },
    toBeMarble: function (actual, marbles) {
        Scheduler.get().expectObservable(actual).toBe(stripAlignmentChars(marbles));
        return dummyResult;
    },
    toSatisfyOnFlush: function (actual, func) {
        Scheduler.get().expectObservable(actual);
        // tslint:disable:no-string-literal
        var flushTests = Scheduler.get()['flushTests'];
        flushTests[flushTests.length - 1].ready = true;
        onFlush.push(func);
        return dummyResult;
    }
});
var onFlush = [];
beforeEach(function () { Scheduler.init(); onFlush = []; });
afterEach(function () {
    Scheduler.get().flush();
    while (onFlush.length > 0) {
        // @ts-ignore
        onFlush.shift()();
    }
    Scheduler.reset();
});
//# sourceMappingURL=index.js.map