/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.ts":
/*!*******************************!*\
  !*** ./index.ts + 10 modules ***!
  \*******************************/
/*! exports provided: Scheduler, hot, cold, time */
/*! ModuleConcatenation bailout: Cannot concat with external "expect/build/jasmineUtils" (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with external "jest-matcher-utils" (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with external "rxjs" (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with external "rxjs/internal/testing/SubscriptionLog" (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with external "rxjs/internal/testing/TestScheduler" (<- Module is not an ECMAScript module) */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: external "rxjs"
var external_rxjs_ = __webpack_require__("rxjs");

// EXTERNAL MODULE: external "rxjs/internal/testing/TestScheduler"
var TestScheduler_ = __webpack_require__("rxjs/internal/testing/TestScheduler");

// EXTERNAL MODULE: external "rxjs/internal/testing/SubscriptionLog"
var SubscriptionLog_ = __webpack_require__("rxjs/internal/testing/SubscriptionLog");

// EXTERNAL MODULE: external "expect/build/jasmineUtils"
var jasmineUtils_ = __webpack_require__("expect/build/jasmineUtils");

// EXTERNAL MODULE: external "jest-diff"
var external_jest_diff_ = __webpack_require__("jest-diff");

// EXTERNAL MODULE: external "jest-matcher-utils"
var external_jest_matcher_utils_ = __webpack_require__("jest-matcher-utils");

// CONCATENATED MODULE: ./src/marbles-glossary.ts
var MarblesGlossary;
(function (MarblesGlossary) {
    MarblesGlossary["Completion"] = "|";
    MarblesGlossary["Error"] = "#";
    MarblesGlossary["TimeFrame"] = "-";
    MarblesGlossary["Subscription"] = "^";
    MarblesGlossary["Unsubscription"] = "!";
    MarblesGlossary["GroupStart"] = "(";
    MarblesGlossary["GroupEnd"] = ")";
})(MarblesGlossary || (MarblesGlossary = {}));

// CONCATENATED MODULE: ./src/notification-event.ts
class NotificationEvent {
    constructor(start) {
        this.start = start;
        this.marbles = '';
    }
    get end() {
        return this.start + this.marbles.length;
    }
}

// CONCATENATED MODULE: ./src/notification-kind.ts

const ValueLiteral = {};
const NotificationKindChars = {
    N: ValueLiteral,
    C: MarblesGlossary.Completion,
    E: MarblesGlossary.Error,
};

// CONCATENATED MODULE: ./src/marblizer.ts



const frameStep = 10;
class marblizer_Marblizer {
    static marblize(messages) {
        const emissions = marblizer_Marblizer.getNotificationEvents(messages);
        let marbles = '';
        for (let i = 0, prevEndFrame = 0; i < emissions.length; prevEndFrame = emissions[i].end, i++) {
            marbles = `${marbles}${MarblesGlossary.TimeFrame.repeat(emissions[i].start - prevEndFrame) +
                emissions[i].marbles}`;
        }
        return marbles;
    }
    static marblizeSubscriptions(logs) {
        return logs.map(log => MarblesGlossary.TimeFrame.repeat(log.subscribedFrame / frameStep) +
            MarblesGlossary.Subscription +
            MarblesGlossary.TimeFrame.repeat((log.unsubscribedFrame - log.subscribedFrame) / frameStep - 1) +
            MarblesGlossary.Unsubscription);
    }
    static getNotificationEvents(messages) {
        const framesToEmissions = messages.reduce((result, message) => {
            if (!result[message.frame]) {
                result[message.frame] = new NotificationEvent(message.frame / frameStep);
            }
            const event = result[message.frame];
            event.marbles += marblizer_Marblizer.extractMarble(message);
            return result;
        }, {});
        const events = Object.keys(framesToEmissions).map(frame => framesToEmissions[frame]);
        marblizer_Marblizer.encloseGroupEvents(events);
        return events;
    }
    static extractMarble(message) {
        let marble = NotificationKindChars[message.notification.kind];
        if (marble === ValueLiteral)
            marble = message.notification.value;
        return marble;
    }
    static encloseGroupEvents(events) {
        events.forEach(event => {
            if (event.marbles.length > 1) {
                event.marbles = `${MarblesGlossary.GroupStart}${event.marbles}${MarblesGlossary.GroupEnd}`;
            }
        });
    }
}

// CONCATENATED MODULE: ./src/jest/custom-matchers.ts




function canMarblize(...messages) {
    return messages.every(message => message.filter(({ notification: { kind } }) => kind === 'N').every(isCharacter));
}
function isCharacter({ notification: { value } }) {
    return ((typeof value === 'string' && value.length === 1) || (value !== undefined && JSON.stringify(value).length === 1));
}
const customTestMatchers = {
    toBeNotifications(actual, expected) {
        let actualMarble = actual;
        let expectedMarble = expected;
        if (canMarblize(actual, expected)) {
            actualMarble = marblizer_Marblizer.marblize(actual);
            expectedMarble = marblizer_Marblizer.marblize(expected);
        }
        const pass = Object(jasmineUtils_["equals"])(actualMarble, expectedMarble);
        const message = pass
            ? () => Object(external_jest_matcher_utils_["matcherHint"])('.not.toBeNotifications') +
                '\n\n' +
                `Expected notifications to not be:\n` +
                `  ${Object(external_jest_matcher_utils_["printExpected"])(expectedMarble)}\n` +
                `But got:\n` +
                `  ${Object(external_jest_matcher_utils_["printReceived"])(actualMarble)}`
            : () => {
                const diffString = external_jest_diff_(expectedMarble, actualMarble, {
                    expand: true,
                });
                return (Object(external_jest_matcher_utils_["matcherHint"])('.toBeNotifications') +
                    '\n\n' +
                    `Expected notifications to be:\n` +
                    `  ${Object(external_jest_matcher_utils_["printExpected"])(expectedMarble)}\n` +
                    `But got:\n` +
                    `  ${Object(external_jest_matcher_utils_["printReceived"])(actualMarble)}` +
                    (diffString ? `\n\nDifference:\n\n${diffString}` : ''));
            };
        return { actual, message, pass };
    },
    toBeSubscriptions(actual, expected) {
        const actualMarbleArray = marblizer_Marblizer.marblizeSubscriptions(actual);
        const expectedMarbleArray = marblizer_Marblizer.marblizeSubscriptions(expected);
        const pass = subscriptionsPass(actualMarbleArray, expectedMarbleArray);
        const message = pass
            ? () => Object(external_jest_matcher_utils_["matcherHint"])('.not.toHaveSubscriptions') +
                '\n\n' +
                `Expected observable to not have the following subscription points:\n` +
                `  ${Object(external_jest_matcher_utils_["printExpected"])(expectedMarbleArray)}\n` +
                `But got:\n` +
                `  ${Object(external_jest_matcher_utils_["printReceived"])(actualMarbleArray)}`
            : () => {
                const diffString = external_jest_diff_(expectedMarbleArray, actualMarbleArray, {
                    expand: true,
                });
                return (Object(external_jest_matcher_utils_["matcherHint"])('.toHaveSubscriptions') +
                    '\n\n' +
                    `Expected observable to have the following subscription points:\n` +
                    `  ${Object(external_jest_matcher_utils_["printExpected"])(expectedMarbleArray)}\n` +
                    `But got:\n` +
                    `  ${Object(external_jest_matcher_utils_["printReceived"])(actualMarbleArray)}` +
                    (diffString ? `\n\nDifference:\n\n${diffString}` : ''));
            };
        return { actual, message, pass };
    },
    toHaveEmptySubscriptions(actual) {
        const pass = !(actual && actual.length > 0);
        let marbles;
        if (actual && actual.length > 0) {
            marbles = marblizer_Marblizer.marblizeSubscriptions(actual);
        }
        const message = pass
            ? () => Object(external_jest_matcher_utils_["matcherHint"])('.not.toHaveNoSubscriptions') +
                '\n\n' +
                `Expected observable to have at least one subscription point, but got nothing` +
                Object(external_jest_matcher_utils_["printReceived"])('')
            : () => Object(external_jest_matcher_utils_["matcherHint"])('.toHaveNoSubscriptions') +
                '\n\n' +
                `Expected observable to have no subscription points\n` +
                `But got:\n` +
                `  ${Object(external_jest_matcher_utils_["printReceived"])(marbles)}\n\n`;
        return { actual, message, pass };
    },
};
function subscriptionsPass(actualMarbleArray, expectedMarbleArray) {
    if (actualMarbleArray.length !== expectedMarbleArray.length) {
        return false;
    }
    let pass = true;
    for (const actualMarble of actualMarbleArray) {
        if (!expectedMarbleArray.includes(actualMarble)) {
            pass = false;
            break;
        }
    }
    return pass;
}
expect.extend(customTestMatchers);

// CONCATENATED MODULE: ./src/rxjs/assert-deep-equal.ts


function expectedIsSubscriptionLogArray(actual, expected) {
    return ((actual.length === 0 && expected.length === 0) || (expected.length !== 0 && expected[0] instanceof SubscriptionLog_["SubscriptionLog"]));
}
function actualIsSubscriptionsAndExpectedIsEmpty(actual, expected) {
    return expected.length === 0 && actual.length !== 0 && actual[0] instanceof SubscriptionLog_["SubscriptionLog"];
}
function assertDeepEqual(actual, expected) {
    if (!expected)
        return;
    if (actualIsSubscriptionsAndExpectedIsEmpty(actual, expected)) {
        expect(actual).toHaveEmptySubscriptions();
    }
    else if (expectedIsSubscriptionLogArray(actual, expected)) {
        expect(actual).toBeSubscriptions(expected);
    }
    else {
        expect(actual).toBeNotifications(expected);
    }
}

// CONCATENATED MODULE: ./src/rxjs/scheduler.ts


class scheduler_Scheduler {
    static init() {
        scheduler_Scheduler.instance = new TestScheduler_["TestScheduler"](assertDeepEqual);
    }
    static get() {
        if (scheduler_Scheduler.instance) {
            return scheduler_Scheduler.instance;
        }
        throw new Error('Scheduler is not initialized');
    }
    static reset() {
        scheduler_Scheduler.instance = null;
    }
    static materializeInnerObservable(observable, outerFrame) {
        const scheduler = scheduler_Scheduler.get();
        // @ts-ignore
        return scheduler.materializeInnerObservable(observable, outerFrame);
    }
}

// CONCATENATED MODULE: ./src/rxjs/cold-observable.ts


class cold_observable_ColdObservable extends external_rxjs_["Observable"] {
    constructor(marbles, values, error) {
        super();
        this.marbles = marbles;
        this.values = values;
        this.error = error;
        this.source = scheduler_Scheduler.get().createColdObservable(marbles, values, error);
    }
    getSubscriptions() {
        return this.source.subscriptions;
    }
}

// CONCATENATED MODULE: ./src/rxjs/hot-observable.ts


class hot_observable_HotObservable extends external_rxjs_["Observable"] {
    constructor(marbles, values, error) {
        super();
        this.marbles = marbles;
        this.values = values;
        this.error = error;
        this.source = scheduler_Scheduler.get().createHotObservable(marbles, values, error);
    }
    getSubscriptions() {
        return this.source.subscriptions;
    }
}

// CONCATENATED MODULE: ./src/rxjs/strip-alignment-chars.ts
function stripAlignmentChars(marbles) {
    return marbles.replace(/^[ ]+/, '');
}

// CONCATENATED MODULE: ./index.ts
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hot", function() { return hot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cold", function() { return cold; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "time", function() { return time; });
/* concated harmony reexport Scheduler */__webpack_require__.d(__webpack_exports__, "Scheduler", function() { return scheduler_Scheduler; });





function hot(marbles, values, error) {
    return new hot_observable_HotObservable(stripAlignmentChars(marbles), values, error);
}
function cold(marbles, values, error) {
    return new cold_observable_ColdObservable(stripAlignmentChars(marbles), values, error);
}
function time(marbles) {
    return scheduler_Scheduler.get().createTime(stripAlignmentChars(marbles));
}
const dummyResult = {
    message: () => '',
    pass: true
};
expect.extend({
    toHaveSubscriptions(actual, marbles) {
        const sanitizedMarbles = Array.isArray(marbles) ? marbles.map(stripAlignmentChars) : stripAlignmentChars(marbles);
        scheduler_Scheduler.get().expectSubscriptions(actual.getSubscriptions()).toBe(sanitizedMarbles);
        return dummyResult;
    },
    toHaveNoSubscriptions(actual) {
        scheduler_Scheduler.get().expectSubscriptions(actual.getSubscriptions()).toBe([]);
        return dummyResult;
    },
    toBeObservable(actual, expected) {
        scheduler_Scheduler.get().expectObservable(actual).toBe(expected.marbles, expected.values, expected.error);
        return dummyResult;
    },
    toBeMarble(actual, marbles) {
        scheduler_Scheduler.get().expectObservable(actual).toBe(stripAlignmentChars(marbles));
        return dummyResult;
    },
    toSatisfyOnFlush(actual, func) {
        scheduler_Scheduler.get().expectObservable(actual);
        // tslint:disable:no-string-literal
        const flushTests = scheduler_Scheduler.get()['flushTests'];
        flushTests[flushTests.length - 1].ready = true;
        onFlush.push(func);
        return dummyResult;
    }
});
let onFlush = [];
beforeEach(() => { scheduler_Scheduler.init(); onFlush = []; });
afterEach(() => {
    scheduler_Scheduler.get().flush();
    while (onFlush.length > 0) {
        // @ts-ignore
        onFlush.shift()();
    }
    scheduler_Scheduler.reset();
});


/***/ }),

/***/ 0:
/*!************************!*\
  !*** multi ./index.ts ***!
  \************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! C:\Users\Jeb\github\jest-marbles\index.ts */"./index.ts");


/***/ }),

/***/ "expect/build/jasmineUtils":
/*!********************************************!*\
  !*** external "expect/build/jasmineUtils" ***!
  \********************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = expect/build/jasmineUtils;

/***/ }),

/***/ "jest-diff":
/*!****************************!*\
  !*** external "jest-diff" ***!
  \****************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = jest-diff;

/***/ }),

/***/ "jest-matcher-utils":
/*!*************************************!*\
  !*** external "jest-matcher-utils" ***!
  \*************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = jest-matcher-utils;

/***/ }),

/***/ "rxjs":
/*!***********************!*\
  !*** external "rxjs" ***!
  \***********************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = rxjs;

/***/ }),

/***/ "rxjs/internal/testing/SubscriptionLog":
/*!********************************************************!*\
  !*** external "rxjs/internal/testing/SubscriptionLog" ***!
  \********************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = rxjs/internal/testing/SubscriptionLog;

/***/ }),

/***/ "rxjs/internal/testing/TestScheduler":
/*!******************************************************!*\
  !*** external "rxjs/internal/testing/TestScheduler" ***!
  \******************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

module.exports = rxjs/internal/testing/TestScheduler;

/***/ })

/******/ });
//# sourceMappingURL=index.js.map