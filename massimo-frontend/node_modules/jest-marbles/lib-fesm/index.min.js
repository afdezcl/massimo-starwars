!function(t){var e={};function n(r){if(e[r])return e[r].exports;var i=e[r]={i:r,l:!1,exports:{}};return t[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}n.m=t,n.c=e,n.d=function(t,e,r){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)n.d(r,i,function(e){return t[e]}.bind(null,i));return r},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=6)}([function(t,e){t.exports=jest-matcher-utils},function(t,e){t.exports=rxjs},function(t,e){t.exports=rxjs/internal/testing/SubscriptionLog},function(t,e){t.exports=jest-diff},function(t,e){t.exports=rxjs/internal/testing/TestScheduler},function(t,e){t.exports=expect/build/jasmineUtils},function(t,e,n){t.exports=n(7)},function(t,e,n){"use strict";n.r(e);var r,i=n(1),s=n(4),o=n(2),c=n(5),a=n(3),u=n(0);!function(t){t.Completion="|",t.Error="#",t.TimeFrame="-",t.Subscription="^",t.Unsubscription="!",t.GroupStart="(",t.GroupEnd=")"}(r||(r={}));class l{constructor(t){this.start=t,this.marbles=""}get end(){return this.start+this.marbles.length}}const b={},p={N:b,C:r.Completion,E:r.Error},f=10;class d{static marblize(t){const e=d.getNotificationEvents(t);let n="";for(let t=0,i=0;t<e.length;i=e[t].end,t++)n=`${n}${r.TimeFrame.repeat(e[t].start-i)+e[t].marbles}`;return n}static marblizeSubscriptions(t){return t.map(t=>r.TimeFrame.repeat(t.subscribedFrame/f)+r.Subscription+r.TimeFrame.repeat((t.unsubscribedFrame-t.subscribedFrame)/f-1)+r.Unsubscription)}static getNotificationEvents(t){const e=t.reduce((t,e)=>{return t[e.frame]||(t[e.frame]=new l(e.frame/f)),t[e.frame].marbles+=d.extractMarble(e),t},{}),n=Object.keys(e).map(t=>e[t]);return d.encloseGroupEvents(n),n}static extractMarble(t){let e=p[t.notification.kind];return e===b&&(e=t.notification.value),e}static encloseGroupEvents(t){t.forEach(t=>{t.marbles.length>1&&(t.marbles=`${r.GroupStart}${t.marbles}${r.GroupEnd}`)})}}function g({notification:{value:t}}){return"string"==typeof t&&1===t.length||void 0!==t&&1===JSON.stringify(t).length}const m={toBeNotifications(t,e){let n=t,r=e;(function(...t){return t.every(t=>t.filter(({notification:{kind:t}})=>"N"===t).every(g))})(t,e)&&(n=d.marblize(t),r=d.marblize(e));const i=Object(c.equals)(n,r);return{actual:t,message:i?()=>Object(u.matcherHint)(".not.toBeNotifications")+"\n\nExpected notifications to not be:\n"+`  ${Object(u.printExpected)(r)}\n`+"But got:\n"+`  ${Object(u.printReceived)(n)}`:()=>{const t=a(r,n,{expand:!0});return Object(u.matcherHint)(".toBeNotifications")+"\n\nExpected notifications to be:\n"+`  ${Object(u.printExpected)(r)}\n`+"But got:\n"+`  ${Object(u.printReceived)(n)}`+(t?`\n\nDifference:\n\n${t}`:"")},pass:i}},toBeSubscriptions(t,e){const n=d.marblizeSubscriptions(t),r=d.marblizeSubscriptions(e),i=function(t,e){if(t.length!==e.length)return!1;let n=!0;for(const r of t)if(!e.includes(r)){n=!1;break}return n}(n,r);return{actual:t,message:i?()=>Object(u.matcherHint)(".not.toHaveSubscriptions")+"\n\nExpected observable to not have the following subscription points:\n"+`  ${Object(u.printExpected)(r)}\n`+"But got:\n"+`  ${Object(u.printReceived)(n)}`:()=>{const t=a(r,n,{expand:!0});return Object(u.matcherHint)(".toHaveSubscriptions")+"\n\nExpected observable to have the following subscription points:\n"+`  ${Object(u.printExpected)(r)}\n`+"But got:\n"+`  ${Object(u.printReceived)(n)}`+(t?`\n\nDifference:\n\n${t}`:"")},pass:i}},toHaveEmptySubscriptions(t){const e=!(t&&t.length>0);let n;return t&&t.length>0&&(n=d.marblizeSubscriptions(t)),{actual:t,message:e?()=>Object(u.matcherHint)(".not.toHaveNoSubscriptions")+"\n\nExpected observable to have at least one subscription point, but got nothing"+Object(u.printReceived)(""):()=>Object(u.matcherHint)(".toHaveNoSubscriptions")+"\n\nExpected observable to have no subscription points\nBut got:\n"+`  ${Object(u.printReceived)(n)}\n\n`,pass:e}}};function h(t,e){e&&(!function(t,e){return 0===e.length&&0!==t.length&&t[0]instanceof o.SubscriptionLog}(t,e)?!function(t,e){return 0===t.length&&0===e.length||0!==e.length&&e[0]instanceof o.SubscriptionLog}(t,e)?expect(t).toBeNotifications(e):expect(t).toBeSubscriptions(e):expect(t).toHaveEmptySubscriptions())}expect.extend(m);class v{static init(){v.instance=new s.TestScheduler(h)}static get(){if(v.instance)return v.instance;throw new Error("Scheduler is not initialized")}static reset(){v.instance=null}static materializeInnerObservable(t,e){return v.get().materializeInnerObservable(t,e)}}class x extends i.Observable{constructor(t,e,n){super(),this.marbles=t,this.values=e,this.error=n,this.source=v.get().createColdObservable(t,e,n)}getSubscriptions(){return this.source.subscriptions}}class S extends i.Observable{constructor(t,e,n){super(),this.marbles=t,this.values=e,this.error=n,this.source=v.get().createHotObservable(t,e,n)}getSubscriptions(){return this.source.subscriptions}}function O(t){return t.replace(/^[ ]+/,"")}function j(t,e,n){return new S(O(t),e,n)}function E(t,e,n){return new x(O(t),e,n)}function y(t){return v.get().createTime(O(t))}n.d(e,"hot",(function(){return j})),n.d(e,"cold",(function(){return E})),n.d(e,"time",(function(){return y})),n.d(e,"Scheduler",(function(){return v}));const B={message:()=>"",pass:!0};expect.extend({toHaveSubscriptions(t,e){const n=Array.isArray(e)?e.map(O):O(e);return v.get().expectSubscriptions(t.getSubscriptions()).toBe(n),B},toHaveNoSubscriptions:t=>(v.get().expectSubscriptions(t.getSubscriptions()).toBe([]),B),toBeObservable:(t,e)=>(v.get().expectObservable(t).toBe(e.marbles,e.values,e.error),B),toBeMarble:(t,e)=>(v.get().expectObservable(t).toBe(O(e)),B),toSatisfyOnFlush(t,e){v.get().expectObservable(t);const n=v.get().flushTests;return n[n.length-1].ready=!0,$.push(e),B}});let $=[];beforeEach(()=>{v.init(),$=[]}),afterEach(()=>{for(v.get().flush();$.length>0;)$.shift()();v.reset()})}]);
//# sourceMappingURL=index.min.js.map